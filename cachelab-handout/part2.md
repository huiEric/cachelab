# Cache Lab

## Part B

part B是优化矩阵转置算法，使用分块的方法，让Cache的miss次数越少越好

题目给的Cache大小只有 1024B，s=5，E=1，b=5。给的数据大小分别是32×32,64×64,61×67

然后只能只用12个int变量

## 32×32

第一题要求miss次数在300以下，首先观察，Cache的一个块只有32B，也就是只能容纳8个int。这个Cache可以容纳这个matrix的前8行。分块的话，肯定是取8×8的比较合适。先读取A的一行，然后放入B的一列。12个int变量，4个用来循环，其余8个用来存A中块的一行。

对于在对角线上的块，A中每读一行，会有一次miss，也就是miss次数是读取操作的1/8，对于B数组的话，第一次读取这行会产生一次miss，之后对于第i行，只有A中读到第i行的时候，会被移除出Cache，然后存的时候会产生一次miss。可以粗略计算为miss次数是读取次数的1/4。

对于不在对角线上的块，做转置的时候，A还是1/8的miss率，B的每行在Cache中和A的行不冲突 ，所以也是1/8的miss率，我们计算下最后大概多少次miss呢？

大概是 ![4\times 64\times(\frac{1}{8}+\frac{1}{4})+12\times 64\times2\times\frac{1}{8}=288](https://www.zhihu.com/equation?tex=4%5Ctimes+64%5Ctimes%28%5Cfrac%7B1%7D%7B8%7D%2B%5Cfrac%7B1%7D%7B4%7D%29%2B12%5Ctimes+64%5Ctimes2%5Ctimes%5Cfrac%7B1%7D%7B8%7D%3D288)

最后跑出来的答案是287，非常接近。

## 64×64

这题比较难，因为大小和前面变化了，并且次数卡的比较紧，必须1300次以下。

首先考虑Cache中只能放4行A中的行，如果再用8×8的块，前面4行可以填入，后面4行会在Cache中发生冲突，导致miss次数增加。

如果只用4×4的块呢？那么每次Cache中放入8个int，我们却只用4个，浪费严重，我用这个方法最少也只能做到1677次miss。

有一种很巧妙的方法，就是还用8×8的块来做，题目说A数组不能变换，但是说B数组可以任意操作啊。我们必须要一步到位嘛？可否考虑先把数字移动到B中，然后在B中自己做变化。

考虑用同样的miss次数，把更多的数据移动到B中，但是不一定是正确的位置，然后再用同样的miss次数，把A中部分数据移动到B中时，完成把B中前面位置错误数据的纠正。

如图：

![img](https://pic1.zhimg.com/80/v2-85af81ad19187208673aacbb0cb42f69_hd.jpg)

画的线的分割是读入到Cache中的行以及写入到B中的顺序。（第二步有些画错了，A左下角应该是按列取数据）

1. 先考虑把A的上半部分存入到B，但是为了考虑Cache不冲突，所以把右上角的4×4的区域也存在B的右上角。对于在对角线上的块，A的miss率是1/8，B的左上角部分miss率是1/2。对于不在对角线上的块，A的miss率还是1/8，B左上角部分的miss率为1/4.


2. 接下来这步是减少miss率的关键，把A左下角的一列4个数据读出，B右上角的一行4个数据读出，都用int变量暂存，然后把前四个填入B右上角行中，后四个填入B的左下角行中。

 因为从B右上角读取的时候，把块放入了Cache，然后从A往B中填的时候，就不会出现miss操作。

来计算一下miss率，对于在对角线上的块，从A左下角读取miss率为1，B的右上角的操作miss率为1/4，B的左下角miss率为1/4。对于不在对角线的快，A的miss率为1/4，B右上角miss率为0，左下角miss率为1/4。

3. 最后一步就是把A的右下角填入B的右下角，对于在对角线上的块，A的miss率为1/4，B的miss率为1/2.不在对角线上的块，A，B的miss率都为0.

最后我们来计算下miss的次数吧，计算出来近似是1280次，实际我们代码跑出来是1219次 。

## 61×67

不规则的matrix，本质也是用分块来优化Cache的读写，但是不能找到比较显然的规律看出来间隔多少可以填满一个Cache，但是由于要求比较松，我们可以尝试一些分块的大小，直接进行转置操作。尝试到16左右 ，可以小于2000次miss。